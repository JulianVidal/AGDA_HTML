% !TEX root =  ../Dissertation.tex

\chapter{Evaluation}

This section evaluates the Agda Tree and Agda Comp tools with respect to the
function and non-functional requirements set on Chapter \ref{ch:system
requirements}. These requirements outline the purpose of these tools and their
expected behaviour.

\subsection{Agda Tree} \label{sub:eval agda tree}

Agda Tree extracts the definitions and their relationships from any Agda
project, uses Agda to generate the module dependency graph and imports them
into a NetworkX graph. It implements several methods that analyze this
graph for information, meeting all the queries outlined for the definition
graph in Table \ref{tbl:Definition Graph Queries} and the module graph in Table
\ref{tbl:Module Graph Queries}. These methods are then exposed through a
command line interface that lets the user runs those queries on their Agda
project. The python library argparse validates that the input to the queries is
valid. Then CLI the outputs the modules to standard output, which can then be
piped to other utilities. The CLI will work with any Agda project, only the
index files containing all modules needs to be passed in. 

Agda Tree is able to extract s-expressions from any Agda project but depending
on the size of the project and the user's computer it can take more than 10
minutes as seen on Section \ref{sub:agda tree performance}. Most queries are
complete in under 2 seconds regardless of project size, but queries that
require finding a path in the graph can take far longer depending on the size
of the graph. The CLI is documented in the README and the \textsf{--help}
options in the command, making the commands easier to learn and understand.
Since Agda is mainly developed in macOS and Linux, the tools was tested in WSL
and a MacBook Air without issues. If the CLI is provided with bad inputs it
returns an error from NetworkX explaining what the issue was. The code base is
documented through READMEs and unit tested allowing for better maintainability
and testability. Therefore, Agda Tree meets all its functional requirement but
doesn't fully meet its non-functional requirements due to performance issues.
The requirements as described on Table \ref{tbl:Agda Tree Functional Requirements} for functional requirements and Table \ref{tbl:Agda Tree Non-Functional Requirements} for non-functional requirements.

\subsubsection{Limitations}

A major limitation of the tool is finding the maximum path between a node and a
leaf, depending on the node the query can run indefinitely. This greatly limits
the usefulness of the query. Another limitation is the verbosity of the
definition names and amount of definitions. The TypeTopology definition graph
has more than 50,000 definitions but with further inspection not all these
definitions provide valuable information for the user. Sometimes the
definitions come from Agda's backend which the user has no use in seeing. The
definition names become difficult to understand due to their length, and some
definitions are ambiguous, so they require an ID number. Overall making find
the name of a definition a bit cumbersome.


\subsection{Agda Comp} \label{sub:eval agda comp}

Agda Comp effectively uses Agda to generate the module dependency graph and
imports the module dependency graph into Python. Using this graph, Agda Comp
allows for the user to pick between multiple strategies to compiles their
project. The user can choose how many cores the compilation will use to limit
the resource usage. The tool creates the necessary index files and make file,
uses them to compile the project and then cleans up these files. The CLI has a
README and a usage section with the \textsf{--help} options that make the
commands more user-friendly and easy to understand. The argparse library
validates that the correct options are passed in to the CLI or gives a
user-friendly error message if not. The tool is able to discern the project
structure from the index file the user passes in, making it usable across any
Agda project. Therefore, Agda Comp meets most of its functional requirements
except for speeding up compilation for any Agda project which will be explored
in Section \ref{ssub:eval comp strat}.  The functional requirements were
described in Table \ref{tbl:Agda Comp Functional Requirements}.

Agda Comp works for any sized project, it has a simple command line interface
to choose the compilation strategy. It was tested within WSL and macOS, for
compatibility. The codebase is documented with a README and the CLI has a
\textsf{--help} option to help users better understand the tool. The strategies
were tested to ensure correctness and safety. Therefore, Agda Comp meets all of
its non-functional requirements as described on Table \ref{tbl:Agda Comp
Non-Functional Requirements}.

\subsubsection{Limitations} \label{ssub:eval comp limitations}

This approach encounters two significant limitations, the first is that to
create the module dependency graph it has to compile the project. Which means
the only way this method could save time is if the user makes a change the
doesn't change the module dependency graph allowing for a previous dependency
graph to be re-used.

The second limitation is the overhead caused by the loading of the interface
files. Interface files are the compiled Agda source code, when a module is type
checked the information is stored in an interface file and used when compiling
modules that depend on it. Every time a new process is created, it has to load
all the interface files it requires to type-check a module and discard them
once done, then the next process might load the same interface files again
wasting resources. Meanwhile, if everything was compiled in one process like
normal it would only load the interface files once. This suggests that while
parallelization could improve compilation time, it can't be done at the user
level calling the Agda Type Checker multiple times. The Agda Type Checker must
be parallelized from within, this would mean all the necessary interface files
can be loaded once and the type checker can check modules in parallel with less
overhead.

\subsubsection{Compilation Strategies} \label{ssub:eval comp strat}

The following Table \ref{tbl:WSL strategies results} and Table \ref{tbl:martin
strategies results} show the results of the testing of the compilation
strategies. The compilation testing consisted of 7 tests of different
strategies across 3 libraries. The three libraries picked are TypeTopology
\cite{type-topology}, unimath \cite{agda-unimath} and Agda's stdlib
\cite{stdlib}. These libraries vary in size and methodology, for example
unimath structure is of many small independent modules while TypeTopology has
less but longer modules.

The 7 strategies tested are normal, which is the standard compilation which
gives a baseline for the other modules. The unsafe test, which attempts to
compile all modules in 4 index files at the same time, without regards to
safety which shows the potential of parallelization. Then the level strategy
using method A to split modules into index files described in Section
\ref{sub:imp lvl strategy}, the modules in the same level will be tested when
split into 2 index files or 5 index files. The next test is using method B
instead, where each index file has at most 2 modules or 5 modules. Lastly, the
disjoint strategy is tested which has no parameters.

Tested on Agda 2.0.17, WSL has 16GB of ram with 8 performance cores at 5.4 GHz.
Macos tested on Agda 2.0.17 has nGB of ram with n cores and n GHz.

\begin{table}[H]
  \centering
  \caption{Results from WSL Testing Compilation Strategies}
  \label{tbl:WSL strategies results}
  \begin{tblr}{
      colspec={|Q[m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|}, hlines,
      cells   = {font = \fontsize{8pt}{10pt}\selectfont},
    }
    {seconds\\(\%)} & Normal      & Unsafe     & {Level A\\2 cores} & {Level A\\5 cores} & {Level B\\2 cap} & {Level B\\4 cap} & Disjoint    \\
    TypeTopology & {575\\(100\%)} & {280\\(49\%)} & {354\\(62\%)}        & {355\\(62\%)}        & {482\\(84\%)}      & {394\\(69\%)}      & {528\\(92\%)}  \\
    stdlib       & {289\\(100\%)} & {147\\(51\%)} & {265\\(92\%)}        & {243\\(84\%)}        & {309\\(107\%)}     & {261\\(90\%)}      & {289\\(100\%)} \\
    Unimath      & {459\\(100\%)} & {219\\(48\%)} & {862\\(188\%)}       & {362\\(79\%)}        & {717\\(156\%)}     & {644\\(140\%)}     & {462\\(101\%)} \\
  \end{tblr}
\end{table}

\begin{table}[H]
  \centering
  \caption{Results from Martin Escardo Testing Compilation Strategies macOS}
  \label{tbl:martin strategies results}
  \begin{tblr}{
      colspec={|Q[m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|Q[c, m]|}, hlines,
      cells   = {font = \fontsize{8pt}{10pt}\selectfont},
    }
    {seconds\\(\%)} & Normal      & Unsafe     & {Level A\\2 cores} & {Level A\\5 cores} & {Level B\\2 cap} & {Level B\\4 cap} & Disjoint    \\
    TypeTopology & {345\\(100\%)} & {172\\(50\%)} & {287\\(83\%)}        & {265\\(77\%)}        & {344\\(100\%)}     & {295\\(86\%)}      & {369\\(107\%)} \\
    stdlib       & {189\\(100\%)} & {123\\(65\%)} & {241\\(128\%)}       & {197\\(104\%)}       & {231\\(122\%)}     & {203\\(107\%)}     & {203\\(107\%)} \\
    Unimath      & {302\\(100\%)} & {168\\(56\%)} & {863\\(286\%)}       & {575\\(190\%)}       & {633\\(210\%)}     & {568\\(188\%)}     & {304\\(101\%)} \\
  \end{tblr}
\end{table}

The results show that a time saving from compilation is dependent on the
project it is compiling. TypeTopology benefitted the most from the compilations
strategies achieving about a 40\% faster compilation in WSL and 23\% faster
compilation in macOS. Although the results from the remaining Agda projects
aren't as promising, with the macOS results showing no improvement in
compilation time in any safe strategy. The results also show that the
compilation time also depends on the user's system, with WSL achieving  a
speed-up in level A 5 cores with all projects.

The cause in the difference in compilation improvement per project, is likely
due to the limitation discussed in the Section \ref{ssub:eval comp
limitations}. Since unimath has more small modules, there is a large amount of
interface files that are constantly being loaded and unloaded when normal
compilation can load all the interface files at once and keep them. 

\section{Conclusion}

Both Agda Tree and Agda Comp meets most of the functional and non-functional
requirements set out in Chapter \ref{ch:system requirements}. Agda Tree
effectively extracts definition dependency graphs from any Agda project, but it
can take a long time to generate that graph. All queries are implemented,
however some queries can take an indefinite amount of time to complete
depending on the user input. One of the limitations of Agda Tree is the
difficult to understand definitions and definition names, as the Agda backend
doesn't make them user-friendly.

Agda Comp is able to import the module dependency graph from any Agda project
and compile it using different strategies. Although, the effectiveness of those
strategies to lower compilation time varies depending on the system and the
Agda project. The limitation that to create the dependency graph the Agda
project is compiled, means this tool could only be used safely when the user
makes a change that doesn't alter the module dependency graph.


% \begin{itemize}
% \item Mention compilation time reduction, and improvements 
% \item Mention how some queries take too long but were all implemented 
% \item Mention how trees take some time but can be re-used instantaneously 
% \item Creates graph from any agda project
% \end{itemize}

% Usually you evaluate your project with regard to the functional and non-functional
% requirements you set out in the earlier chapter. This doesn’t necessary mean that your project was
% successful but, if these requirements were appropriately specified, you it’s likely that your project was
% successful. You might be reiterating some points from the Testing and Success Measurement
% chapter in your Project Report.

% \begin{itemize}
% \item Explain how agda tree meets the functional and non-functional requirements.
% \item Explain how having each module type check by itself is inneficient due to agai files
% \item Explain how you moved stuff to index to avoid this and different ways to space of the modules  
% \item Explain how conccurently compiling at each level isn't efficient as it
%   would be best to have massive modules with many dependencies be compiled next
%   to other massive modules with disjoint dependnecies. Instead of a couple of
%   modules at a time.
% \item Discuss limitation 
% \item where the tool might need improvement 
% \item Recap of how the CLI tool meets the research objectives 
% \item integraiont into ides
% \end{itemize}

% \begin{itemize}
% \item Explain how the strategies are giong to be tested 
% \item Explain what strategies will be tested and why 
% \item Explain what libraries will be used for testing 
% \item Show table with the results of each test
% \item Discuss limitation, constrints of scenarios 
% \item where the tool might need improvement 
% \item Recap of how the CLI tool meets the research objectives 
% \item Possible improvement havea Agda do type checking from inside and creae
%   module dependenc ygraph without type-checkiing
% \end{itemize}
