% !TEX root =  ../Dissertation.tex

\chapter{Evaluation}

This section evaluates the Agda Tree and Agda Comp tools with respect to the
function and non-functional requirements set on Chapter \ref{ch:system
requirements}. These requirements outline the purpose of these tools and their
expected behaviour.

\subsection{Agda Tree} \label{sub:eval agda tree}

Agda Tree extracts the definitions and their relationships from any Agda
project, uses Agda to generate the module dependency graph and imports them
into a NetworkX graph. Agda Tree implements several methods that analyze this
graph for information, meeting all the queries outlined for the definition
graph in Table \ref{tbl:Definition Graph Queries} and the module graph in Table
\ref{tbl:Module Graph Queries}. These methods are then exposed through a
command line interface that lets the user runs those queries on their Agda
project. The python library argparse validates that the input to the queries is
valid. Then CLI the outputs the modules to standard output, which can then be
piped to other utilities. The CLI will work with any Agda project, only the
index files containing all modules needs to be passed in. 

Agda Tree is able to extract s-expressions from any Agda project but depending
on the size of the project and the user's computer it can take more than 10
minutes as seen on Section \ref{sub:agda tree performance}. Most queries are
complete in under 2 seconds regardless of project size, but queries that
require finding a path in the graph can take far longer depending on the size
of the graph. The CLI is documented in the README and the \textsf{--help}
options in the command, making the commands easier to learn and understand.
Since Agda is mainly developed in macOS and Linux, the tools was tested in WSL
and a MacBook Air without issues. If the CLI is provided with bad inputs it
returns an error from NetworkX explaining what the issue was. The code base is
documented through READMEs and unit tested allowing for better maintainability
and testability. Therefore, Agda Tree meets all its functional requirement but
doesn't fully meet its non-functional requirements due to performance issues.
The requirements as described on Table \ref{tbl:Agda Tree Functional
Requirements} for functional requirements and Table \ref{tbl:Agda Tree
Non-Functional Requirements} for non-functional requirements.

\subsubsection{Limitations}

A major limitation of the tool is finding the maximum path between a node and a
leaf, depending on the node the query can run indefinitely. This greatly limits
the usefulness of the query. Another limitation is the verbosity of the
definition names and amount of definitions. The TypeTopology definition graph
has more than 50,000 definitions but with further inspection not all these
definitions provide valuable information for the user. Sometimes the
definitions come from Agda's backend which the user has no use in seeing. The
definition names become difficult to understand due to their length, and some
definitions are ambiguous, so they require an ID number. Overall making find
the name of a definition a bit cumbersome.


\subsection{Agda Comp} \label{sub:eval agda comp}

Agda Comp effectively uses Agda to generate the module dependency graph and
imports the module dependency graph into Python. Using this graph, Agda Comp
allows for the user to pick between multiple strategies to compiles their
project. The user can choose how many cores the compilation will use to limit
the resource usage. The tool creates the necessary index files and make file,
uses them to compile the project and then cleans up these files. The CLI has a
README and a usage section with the \textsf{--help} options that make the
commands more user-friendly and easy to understand. The argparse library
validates that the correct options are passed in to the CLI or gives a
user-friendly error message if not. The tool is able to discern the project
structure from the index file the user passes in, making it usable across any
Agda project. Therefore, Agda Comp meets most of its functional requirements
except for speeding up compilation for any Agda project which will be explored
in Section \ref{ssub:eval comp strat}.  The functional requirements were
described in Table \ref{tbl:Agda Comp Functional Requirements}.

Agda Comp works for any sized project, it has a simple command line interface
to choose the compilation strategy. It was tested within WSL and macOS, for
compatibility. The codebase is documented with a README and the CLI has a
\textsf{--help} option to help users better understand the tool. The strategies
were tested to ensure correctness and safety. Therefore, Agda Comp meets all of
its non-functional requirements as described on Table \ref{tbl:Agda Comp
Non-Functional Requirements}.

\subsubsection{Limitations} \label{ssub:eval comp limitations}

This approach encounters two significant limitations, the first is that to
create the module dependency graph it has to compile the project. Which means
the only way this method could save time is if the user makes a change the
doesn't change the module dependency graph allowing for a previous dependency
graph to be re-used.

The second limitation is the overhead caused by the loading of the interface
files. Every time a new process is created, it has to load all the interface
files it requires and discard them once done, then the next process might load
the same interface files again. Meanwhile, if everything was compiled in one
process like normal it would only load the interface files once. This suggests
that while parallelization could improve compilation time, it can't be done at
the user level calling the Agda Type Checker multiple times. The Agda Type
Checker must be parallelized from within, this would mean all the necessary
interface files can be loaded once and the type checker can check modules in
parallel with less overhead.

\subsubsection{Compilation Strategies} \label{ssub:eval comp strat}

\begin{table}[H]
\centering
\caption{Results from WSL Testing Compilation Strategies}
\label{tbl:WSL strategies results }
\begin{tblr}{
        colspec={|Q[h, 3]|Q[h,1]|X[1]|X[1]|X[1]|X[1]|X[1]|X[1]|}, hlines,
    }
{seconds\\(\%)} & Normal      & Unsafe     & {Level A\\(2 cores)} & {Level\\A (5 cores)} & Level B (2 cap) & Level B (4 cap) & Disjoint    \\
TypeTopology & {575\\(100\%)} & 280 (49\%) & 354 (62\%)        & 355 (62\%)        & 482 (84\%)      & 394 (69\%)      & 528 (92\%)  \\
stdlib       & {289\\(100\%)} & 147 (51\%) & 265 (92\%)        & 243 (84\%)        & 309 (107\%)     & 261 (90\%)      & 289 (100\%) \\
Unimath      & {459\\(100\%)} & 219 (48\%) & 862 (188\%)       & 362 (79\%)        & 717 (156\%)     & 644 (140\%)     & 462 (101\%) \\
\end{tblr}
\end{table}

\begin{table}[]
\begin{tabular}{|l|c|c|c|c|c|c|c|}
seconds (\%) & Normal      & Unsafe     & Level A (2 cores) & Level A (5 cores) & Level B (2 cap) & Level B (4 cap) & Disjoint    \\ \hline
TypeTopology & 345 (100\%) & 172 (50\%) & 287 (83\%)        & 265 (77\%)        & 344 (100\%)     & 295 (86\%)      & 369 (107\%) \\ \hline
stdlib       & 189 (100\%) & 123 (65\%) & 241 (128\%)       & 197 (104\%)       & 231 (122\%)     & 203 (107\%)     & 203 (107\%) \\ \hline
Unimath      & 302 (100\%) & 168 (56\%) & 863 (286\%)       & 575 (190\%)       & 633 (210\%)     & 568 (188\%)     & 304 (101\%) \\ \hline
\end{tabular}
\end{table}


\begin{itemize}
\item Mention compilation time reduction, and improvements 
\item Mention how some queries take too long but were all implemented 
\item Mention how trees take some time but can be re-used instantaneously 
\item Creates graph from any agda project
\end{itemize}

% Usually you evaluate your project with regard to the functional and non-functional
% requirements you set out in the earlier chapter. This doesn’t necessary mean that your project was
% successful but, if these requirements were appropriately specified, you it’s likely that your project was
% successful. You might be reiterating some points from the Testing and Success Measurement
% chapter in your Project Report.

\begin{itemize}
\item Explain how agda tree meets the functional and non-functional requirements.
\item Explain how having each module type check by itself is inneficient due to agai files
\item Explain how you moved stuff to index to avoid this and different ways to space of the modules  
\item Explain how conccurently compiling at each level isn't efficient as it
  would be best to have massive modules with many dependencies be compiled next
  to other massive modules with disjoint dependnecies. Instead of a couple of
  modules at a time.
\item Discuss limitation 
\item where the tool might need improvement 
\item Recap of how the CLI tool meets the research objectives 
\item integraiont into ides
\end{itemize}

\begin{itemize}
\item Explain how the strategies are giong to be tested 
\item Explain what strategies will be tested and why 
\item Explain what libraries will be used for testing 
\item Show table with the results of each test
\item Discuss limitation, constrints of scenarios 
\item where the tool might need improvement 
\item Recap of how the CLI tool meets the research objectives
\end{itemize}

