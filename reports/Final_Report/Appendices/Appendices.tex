\chapter{Appendix}

% Some information, for example program listings, is useful to include within the report
% for completeness, but would distract the reader from the flow of the discussion if it were included
% within the body of the document. Short extracts from major programs may be included to illustrate
% points but full program listings should only ever be placed within an appendix. Remember that the
% point of appendices is to make your report more readable. I donâ€™t expect to see apprentices in any
% Project Proposals.

\begin{lstlisting}[caption={Agda Comp Help Message},label={code:agda comp help}]
usage: agda_comp [-h] [-c] [-j JOBS] [-s {level,levelb,normal,unsafe,disjoint}] module

Fast Agda type checker

positional arguments:
  module                Path to module to compile

options:
  -h, --help            show this help message and exit
  -c, --clean           Create dot file even if it already exists
  -j, --jobs JOBS       Cores that can be used
  -s, --strategy {level,levelb,normal,unsafe,disjoint}
                        The strategy that will determine the compilation order, the
                        choices are: level: Sorts modules into levels, each level
                        increses the length to a leaf, lvl 5 are the modules that 5
                        modules away from a leaf. Each level is then split into 4 files
                        or the value given by --jobs levelb: Sorts modules by levels
                        like in 'level' but instead each level is separated into n files
                        with --jobs modules each normal: Normal compilation unsafe:
                        Tries to compile all the modules with 4 concurrent index files
                        or --jobs files disjoint: Finds the biggest modules that are
                        disjoint, if none are found the leaves are removed then repeats
\end{lstlisting}

\begin{lstlisting}[caption={Agda Tree Definition Help Message},label={code:definition help}]
usage: agda_tree definition [-h]
                            {create_tree,cycles,dependencies,
                            dependents, find,leafs,
                            module_dependencies,module_dependents,
                            module_path_to_leaf,nodes,path_between,
                            path_to_leaf, roots,save_tree,type,uses}
                            ...

positional arguments:
  {create_tree,cycles,dependencies,dependents,
  find,leafs,module_dependencies,module_dependents,
  module_path_to_leaf,nodes,path_between,path_to_leaf,
  roots,save_tree,type,uses}
    create_tree         Creates definition dependency tree from file, 
                        -output option to set the path 
                        to store the tree
    cycles              Cycles in graph
    dependencies        Definitions that definition d depends on,
                        -indirect will find the indirect dependencies
    dependents          Definitions that depend on definition d,
                        -indirect finds the indirect dependents
    find                Find definition through regex
    leafs               Definitions with no dependencies
    module_dependencies
                        Module dependencies of definition d, 
                        -indirect finds the indirect 
                        module dependencies
    module_dependents   Modules that depend on definition d, 
                        -indirect also gets the indirect 
                        module dependents
    module_path_to_leaf
                        Longest path from definition d to any leaf only
                        counting modules
    nodes               List of definitions, if -c flag is set returns 
                        the number of nodes
    path_between        Longest path between two definitions src 
                        and dst
    path_to_leaf        Longest path from defintion d to any leaf
    roots               Definitions that aren't used
    save_tree           Save definition graph as pydot
    type                Types of definition d
    uses                Counts amount of uses per definition, 
                        sorted in descending order, if -d is passed 
                        in a definitino it will return the uses 
                        of that definition

options:
  -h, --help            show this help message and exit
\end{lstlisting}

\begin{lstlisting}[caption={Agda Tree Module Help Message},label={code:module help}]
usage: agda_tree module [-h]
                        {complex_modules,create_tree,dependencies,
                        dependents,find,leafs,lvl_sort,nodes,
                        path_between,path_to_leaf,roots,topo_sort,
                        uses} ...

positional arguments:
  {complex_modules,create_tree,dependencies,
  dependents,find,leafs,lvl_sort,nodes,
  path_between,path_to_leaf,roots,topo_sort,
  uses}
    complex_modules     Get the top modules that have the most dependents
    create_tree         Creates modules dependency tree from file
    dependencies        Modules that module m imports
    dependents          Modules that import module m
    find                Find module through regex
    leafs               Modules with no imports
    lvl_sort            Level sort
    nodes               List of modules
    path_between        Longest path between two modules src and dst
    path_to_leaf        Longest path from module m to any leaf
    roots               Modules that aren't imported
    topo_sort           Topological sort
    uses                Counts how many times a module is imported, sorted
                        in descending order

options:
  -h, --help            show this help message and exit
\end{lstlisting}

% \label{code:lvl_sort}
\begin{lstlisting}[caption={Level Sort Algorithm},label={code:lvl sort}]
def depth(g, node, mem):
    if node in mem:
        return mem

    children = list(g.successors(node))
    if len(children) == 0:
        mem[node] = 0
        return mem

    for c in children:
        m = depth(g, c, mem)
        mem |= m
        mem[node] = max(mem.get(node, 0), mem[c])
    mem[node] += 1

    return mem

def depths(g):
    m = {}
    for n in g.nodes:
        m |= depth(g, n, m)
    return m
\end{lstlisting}

\begin{table}[H]
  \centering
  \caption{Computer Specifications for WSL 13900hx}
  \label{tbl:WSL specs}
  \begin{tblr}{
      colspec={|Q[m]|Q[c, m]|}, hlines,
      cells   = {font = \fontsize{8pt}{10pt}\selectfont},
    }
    Specification                 &             \\
    Max Clock (GHz)               & 5.4         \\
    CPU P-cores                   & 8           \\
    CPU E-Cores                   & 16          \\
    RAM (GB)                      & 24          \\
    Cooling                       & Active      \\
  \end{tblr}
\end{table}

\begin{table}[H]
  \centering
  \caption{Computer Specifications for Mac Mini M4}
  \label{tbl:martin specs}
  \begin{tblr}{
      colspec={|Q[m]|Q[c, m]|}, hlines,
      cells   = {font = \fontsize{8pt}{10pt}\selectfont},
    }
    Specification                 &             \\
    Max Clock (GHz)               & 4.4         \\
    CPU P-cores                   & 4           \\
    CPU E-Cores                   & 6           \\
    RAM (GB)                      & 24          \\
    Cooling                       & Active      \\
  \end{tblr}
\end{table}

\begin{table}[H]
  \centering
  \caption{Computer Specifications for MacBook Air M4}
  \label{tbl:mba specs}
  \begin{tblr}{
      colspec={|Q[m]|Q[c, m]|}, hlines,
      cells   = {font = \fontsize{8pt}{10pt}\selectfont},
    }
    Specification                 &             \\
    Max Clock (GHz)               & 4.4         \\
    CPU P-cores                   & 4           \\
    CPU E-Cores                   & 6           \\
    RAM (GB)                      & 16          \\
    Cooling                       & Passive     \\
  \end{tblr}
\end{table}

