% !TEX root =  ../Dissertation.tex

\chapter{Introduction}

% The introduction should provide content for the report, discuss relevant background
% material, identify stakeholders, and state the aim(s) of the work. About 10\% of
% the report.

\todo[inline]{Add citations to articles about code decay and refactoring?}
\section{Background}

When first encountering a massive code base with years of development it can be
overwhelming and difficult to parse through \cite{code_decay}. On most
libraries you can ignore its low-level functions, but in Agda it is useful to
know the underlying definitions for future proofs. This creates the need for
tools to improve this experience, such as using dependency graphs of code to
find parts to refactor \cite{dep_grah_refactoring}.

Agda is a functional programming language that used as a proof assistant,
following the propositions as types logic system \cite{agda_docs}. Since proofs
in Agda are made from scratch, defining the most fundamental types and
operations means that projects will quickly balloon. While most of the time, it
is possible to use high-level definitions when making a proof, knowing how
the types are fundamentally defined is beneficial. 

\section{Motivation}

Due to the size of these projects and the complexity of the types it becomes
difficult to fully grasp what the relationships between the definitions. This
creates the need for a tool that can analyse Agda projects and give the user an
easy-to-use interface to query these relationships and better understand the
proofs. It would also benefit during refactoring which deals with code decay
\cite{fowler2018refactoring}.

This tool would make it easier to refactor modules and change the structure of the
project. For example, if a definition isn't used often, it
can be removed, if a module depends on many other definitions it could be
split into smaller parts. This information would give the user a better
idea on where to put their focus.

In addition, large Agda projects have to deal with long compilation times. Agda
is a proof assistant, during "compilation", it type-checks the entire project
which can take 5 minutes or more depending on the computer and project.
Normally not an issue on high-level files, as Agda will keep tracked of the
modified modules and only compile the modules changed and its dependents.

However, low-level files with many dependents, will cause a significant portion
of the project to re-compile. This effect is particularly pronounced during
refactoring where significant changes will be made to the structure of the
project, causing Agda to re-check the whole project wasting time. 

Agda type checks projects by going through the dependencies of each module
sequentially. Meaning it could benefit from parallelization, as long as,
modules are compiled safely without overlap there is potential for a speed-up.
Therefore, A tool uses the relationship between the modules and finds modules
that are safe to compile in parallel could lead to significant time savings.

\section{Problem Statement}

Agda doesn't provide a built-in tool to extract the definitions from a project,
but there is an s-expression extractor by Andrej Bauer \cite{andrej} that
allows for a better view of Agda's internal representation. Although,
S-expressions aren't a well-suited data structure for querying these
definitions \todo{do i need to explain why s-expressions aren't well suited?}.
They are structured for syntax and contain other information that can be
discarded. A better data structure would be a graph, that contains the
definitions as nodes are their relationships as edges. A tool that could
explore this dependency graph of definitions, would let the user get a better
graphs of large code bases faster.

Also, Agda does have a command to create a dependency graph of the modules. For
compilation time improvement, only modules are of interest as such an effective
representation is already available. The challenge is what is the most
effective way to traverse a dependency graph, concurrently, while maintaining
safety (i.e. don't compile modules and their dependencies at the same time).
Different strategies have to be tested against well-known libraries to gauge
its effectiveness. \todo{Explain further what the challenges are}

\section{Objectives}

The objective of this project is to create a (Command Line Interface) CLI that
generate the dependency graph from any Agda project using the s-expression
representation \cite{andrej}. Then the user access to queries that will let the
user explore the graph and gain insight into the Agda project. There aren't
any tools currently that have these features. 

The second objective is to build a CLI tool that reduces compilation time. By
automatically generating the module dependency graph from an Agda project.
Applying a strategy to find the optimal order that modules should be compiled
in parallel while maintaining safety. And lastly, running that strategy,
compiling the entire project.

\section{Project Structure} \todo{Is this section necessary?}

First, there will be an exploration of related works pertaining to using graphs
for code analysis. As well as, an explanation of s-expressions, other instances
of parallel computation and describing the scheduling problem. \todo{do i need
to explain the scheduling problem, how thoroughly?}. Second, the requirements
and overall design of the CLI tools will be own, along with an explanation of
what strategic are going to be employed for compilation. Third, an explanation
of the implementation of the designed systems. Fourth, an evaluation of the
tools and the performance of the compilation strategies. Lastly, an overview of
the results, limitations and future improvements.
