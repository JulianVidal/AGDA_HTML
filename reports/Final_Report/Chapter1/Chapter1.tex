% !TEX root =  ../Dissertation.tex

\chapter{Introduction}

% The introduction should provide content for the report, discuss relevant background
% material, identify stakeholders, and state the aim(s) of the work. About 10\% of
% the report.

\todo[inline]{Add citations to articles about code decay and refactoring?}
\section{Background}

Large codebases with years of development can be overwhelming to navigate
\cite{code_decay} and in Agda understanding the underlying definitions is
important for new proofs. Dependency graphs can help in navigating the code
base and identifying areas needing refactoring\cite{dep_grah_refactoring}.

Agda is a functional programming language and proof-assistant that
follows the propositions-as-types logic system \cite{agda_docs}. Since proofs
in Agda are made from scratch, defining the most fundamental types and
operations means that projects will balloon. While most of the time, it
is possible to use high-level definitions when making a proof, knowing how the
types are fundamentally defined is beneficial. 

\section{Motivation}

The size and complexity of these projects make it challenging to understand
relationships between definitions. There is a need for a tool that analyses
Agda projects and gives the user an easy-to-use interface to query these
relationships and better understand their proofs. 

Refactoring and changing the structure of the project becomes easier which
helps with code decay \cite{fowler2018refactoring}. For example, if a
definition isn't used often, it can be removed, if a module depends on many
other definitions it could be split into smaller parts. This information would
give the user a better idea on where to put their focus.

In addition, large Agda projects have to deal with long compilation times. Agda
is a proof-assistant, during compilation, it type-checks the entire project
which can take 5 minutes or more depending on the computer and project.
Normally not an issue on high-level files, as Agda keeps track of the
modified modules and only compile the modules changed and its dependents.

However, low-level files with many dependents, will cause a significant portion
of the project to re-compile. This effect is particularly pronounced during
refactoring where significant changes will be made to the structure of the
project, causing Agda to re-check the whole project wasting time. 

Agda's type-checking process checks module dependencies in sequential order.
This presents the opportunity for parallel execution, given that modules can be
compiled concurrently without dependency conflicts. There is potential for a
speed-up. Therefore, a tool that finds modules which are safe to compile in
parallel could lead to time savings.

\section{Problem Statement}

Agda doesn't have built-in tools for extracting project definitions. However,
Andrej Bauer's s-expression extractor gives a view into Agda's internal
representation \cite{andrej}. Although, S-expressions are not an ideal data
structure for querying these definitions. A graph is data structure, where the
definitions are nodes are their relationships are edges. A tool to explore this
dependency graph of definitions, would let the user get a better grasp of large
code bases.

To compile modules safely a module dependency graph is need which Agda already
provides. The challenge is finding an effective way to concurrently traverse
the graph, while maintaining safety. Different strategies have to be tested
against well-known libraries to gauge its effectiveness. \todo{Explain further
what the challenges are}

\section{Objectives}

The objective of this project is to create a Command-Line Interface (CLI) that
generate the dependency graph from any Agda project using the s-expression
representation \cite{andrej}. Then the user access to queries that will let the
user explore the graph and gain insight into the Agda project. There aren't
any tools currently that have these features. 

The second objective is to build a CLI tool that reduces compilation time. By
automatically generating the module dependency graph from an Agda project.
Applying a strategy to find the optimal order that modules should be compiled
in parallel while maintaining safety. And lastly, running that strategy,
compiling the entire project.

\section{Project Structure}

First, there will be an exploration of related works pertaining to using graphs
for code analysis. As well as, an explanation of s-expressions, other instances
of parallel computation and describing the scheduling problem. \todo{do i need
to explain the scheduling problem, how thoroughly?}. Second, the requirements
and overall design of the CLI tools will be own, along with an explanation of
what strategic are going to be employed for compilation. Third, an explanation
of the implementation of the designed systems. Fourth, an evaluation of the
tools and the performance of the compilation strategies. Lastly, an overview of
the results, limitations and future improvements.
