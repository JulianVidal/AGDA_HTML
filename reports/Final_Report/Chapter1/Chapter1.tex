% !TEX root =  ../Dissertation.tex

\chapter{Introduction}

% The introduction should provide content for the report, discuss relevant background
% material, identify stakeholders, and state the aim(s) of the work. About 10\% of
% the report.

\todo[inline]{Add citations to articles about code decay and refactoring?}
\section{Background}

When first encountering a massive code base with years of development it can be
overwhelming and difficult to parse through \cite{code_decay}. On most
libraries you can ignore its low-level functions, but in Agda it is useful to
know the underlying definitions for future proofs. This creates the need for
tools to improve this experience, such as using dependency graphs of code to
find parts to refactor \cite{dep_grah_refactoring}.

Agda is a functional programming language, that works as a proof assistant that
follows the propositions-as-types logic system \cite{agda_docs}. Since proofs
in Agda are made from scratch, defining the most fundamental types and
operations means that projects will quickly balloon. While most of the time, it
is possible to use high-level definitions when making a proof, knowing how the
types are fundamentally defined is beneficial. 

\section{Motivation}

Due to the size and complexity of these projects it becomes difficult to fully
grasp what the relationships between the definitions. This creates the need for
a tool that can analyse Agda projects and give the user an easy-to-use
interface to query these relationships and better understand the proofs. It
would also benefit during refactoring which deals with code decay
\cite{fowler2018refactoring}.

This tool would make it easier to refactor modules and change the structure of the
project. For example, if a definition isn't used often, it
can be removed, if a module depends on many other definitions it could be
split into smaller parts. This information would give the user a better
idea on where to put their focus.

In addition, large Agda projects have to deal with long compilation times. Agda
is a proof assistant, during "compilation", it type-checks the entire project
which can take 5 minutes or more depending on the computer and project.
Normally not an issue on high-level files, as Agda keeps track of the
modified modules and only compile the modules changed and its dependents.

However, low-level files with many dependents, will cause a significant portion
of the project to re-compile. This effect is particularly pronounced during
refactoring where significant changes will be made to the structure of the
project, causing Agda to re-check the whole project wasting time. 

Agda's type-checking process checks module dependencies in sequential order.
This presents the opportunity for parallel execution, given that modules can be
compiled concurrently without dependency conflicts. There is potential for a
speed-up. Therefore, a tool that finds modules which are safe to compile in
parallel could lead to time savings.

\section{Problem Statement}

Agda doesn't provide a built-in tool to extract the definitions from a project,
but there is an s-expression extractor by Andrej Bauer \cite{andrej} that
allows for a better view of Agda's internal representation. Although,
S-expressions are not an ideal data structure for querying these definitions,
as they are structured for syntax and contains extra unnecessary information.
A better data structure would be a graph, that contains the definitions as
nodes are their relationships as edges. A tool that could explore this
dependency graph of definitions, would let the user get a better graph of large
code bases faster.

Also, Agda does have a command to create a dependency graph of the modules. For
compilation time improvement, only modules are of interest as such an effective
representation is already available. The challenge is what is the most
effective way to traverse a dependency graph, concurrently, while maintaining
safety (i.e. do not compile modules and their dependencies at the same time).
Different strategies have to be tested against well-known libraries to gauge
its effectiveness. \todo{Explain further what the challenges are}

\section{Objectives}

The objective of this project is to create a Command-Line Interface (CLI) that
generate the dependency graph from any Agda project using the s-expression
representation \cite{andrej}. Then the user access to queries that will let the
user explore the graph and gain insight into the Agda project. There aren't
any tools currently that have these features. 

The second objective is to build a CLI tool that reduces compilation time. By
automatically generating the module dependency graph from an Agda project.
Applying a strategy to find the optimal order that modules should be compiled
in parallel while maintaining safety. And lastly, running that strategy,
compiling the entire project.

\section{Project Structure}

First, there will be an exploration of related works pertaining to using graphs
for code analysis. As well as, an explanation of s-expressions, other instances
of parallel computation and describing the scheduling problem. \todo{do i need
to explain the scheduling problem, how thoroughly?}. Second, the requirements
and overall design of the CLI tools will be own, along with an explanation of
what strategic are going to be employed for compilation. Third, an explanation
of the implementation of the designed systems. Fourth, an evaluation of the
tools and the performance of the compilation strategies. Lastly, an overview of
the results, limitations and future improvements.
