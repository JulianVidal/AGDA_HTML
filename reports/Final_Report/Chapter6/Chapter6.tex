% !TEX root =  ../Dissertation.tex

\chapter{Implementation} \label{ch:implementation}

The code for this chapter can be found at \cite{agda_html}. Agda Tree creates a
dependency definition graph from an Agda project and lets the user query this
graph through a CLI. This system must meet the functional requirements
described on \cref{tbl:Agda Tree Functional Requirements} and the
non-functional requirements described on \cref{tbl:Agda Tree Non-Functional
Requirements}. The CLI implements all the queries described on
\cref{tbl:Definition Graph Queries} for the definition graph and the queries
described in \cref{tbl:Module Graph Queries} for the module graph. Agda Comp
uses the module dependency graph to execute a strategy that returns the
compilation order of the modules. It then compiles the project using that
order. This system must meet the functional requirements described on
\ref{tbl:Agda Comp Functional Requirements} and the non-functional requirements
described on \ref{tbl:Agda Comp Non-Functional Requirements}.



% This section should discuss how you went about developing a system that was
% consistent with your design to meet your stated requirements. The
% implementation of subsystems should be accurately documented, with any
% implementation difficulties being acknowledged. The Design and Implementation
% sections can be grouped in the Project Report, if these are tightly coupled.
% Likely omitted for the Project Proposal, though should mention your proposed
% implementation technologies somewhere.

% \begin{itemize}
% \item File structure and project structure
% \end{itemize}

\section{Agda Tree}

Agda Tree \cite{agda_html} uses the s-expression extractor \cite{andrej} to get the definitions
and relationships from the project. These s-expressions are parsed and
converted into a definition dependency graph. Which is then exposed through a
CLI that the user can query. Agda already includes a command to generate the
module dependency graph, so it only needs to be imported and attached to a CLI.

\subsection{Building the dependency graphs}

Agda's backend has the information needed to find the definitions and their
dependencies, in an Agda project. Natively there isn't a way to retrieve this
information but Andrej Bauer, Matej Petković, Ljupčo Todorovski in their paper
"MLFMF: Data Sets for Machine Learning for Mathematical Formalization"
\cite{bauer2023mlfmf} created an s-expression extractor. The s-expression
extractor works in the backend, and converts Agda source code into
s-expressions \cite{andrej} which are easy to parse.

\subsubsection{S-expression extractor}

The s-expression notation is used in Lisp programming languages, it represents
programs and data as tree-like structures \cite{sexp}. The grammar for the
s-expressions varies, but for this case the s-expression are of the form: \texttt{(:tag
sexp-1 sexp-2 ... sexp-n)}. Where \texttt{sexp-n} can be a number, a string or another
s-expression and the tag is a keyword that describes the content of the
s-expression. The MLFMF paper describes in more detail the structure of the
s-expressions with respect to Agda \cite{bauer2023mlfmf}.

Here is a brief summary of the relevant s-expressions that are needed for the implementation:

\begin{table}[H]
\centering
\caption{Relevant S-expressions}
\label{tbl:sexp}
\begin{tblr}{
        colspec={|X[1]|X[2]|}, hlines,
    }
sexp                              & Description                                                                                                                  \\
(:module module-name entries... ) & Root tag that holds the whole module, module-name is the name of the modules and entries are the definitions in the implementation \\
(:module-name name)               & Module name                                                                                                              \\
(:entries name type body)         & Definition, it includes its name, type and the body of the definition                                                    \\
(:name name)                      & Name of a definition, this name can appear as the name of an :entry tag, within the :type or :body tag                   \\
(:type type)                      & Description of the type of the parent definition                                                                         \\
(:body body)                      & Body of a definition  
\end{tblr}
\end{table}

Note that the s-expression extractor is a modified version of Agda, which means
the user has to compile this Agda version and add it to their path. This will
be handled by the CLI described \cref{sub:Agda Tree CLI} to make sure the
usability non-functional requirement is met from \cref{tbl:Agda Tree
Non-Functional Requirements}.

\subsubsection{S-expression parser}\label{sub:s-expression parser implementation}

The S-expression parser extracts only the relevant information from Agda's
s-expressions. Specifically the \texttt{:entry} and \texttt{:name} tags, which
represent definitions and their dependencies. The s-expressions are generated
and stored in a directory, then processed using Python's sexpdata library to
load them into lists. These lists are traversed recursively to collect the
required tags.

The parsing methodology involves finding all \texttt{:entry} tags, each
representing a definition. For every \texttt{:entry}, the nested \texttt{:name}
tags are extracted to construct a dictionary where each key is a definition
name, and its value is a list of dependencies. This dictionary maps all
definitions to their dependencies. A helper function, \texttt{find\_exp}, is
implemented to recursively traverse the s-expression structure and collect
specific tags.

The parser processes each module file separately and in parallel, generating a
dictionary for each. These dictionaries are then merged into a single
dictionary containing all definitions and dependencies across the project.
Additionally, a similar process is applied to extract type information by
analysing \texttt{:type} tags within the s-expressions. This produces another
dictionary mapping definitions to their types.

% \begin{itemize}
%     \item How the s-expression are extracted
%     \item How the extractor is installed
%     \item how the s-expressions are parsed
%     \item What are s-expressions and how they work
%     \item How to get the s-expression definition and relationships
%     \item Explains how the tag works in this context i.e. name are definitions 
%     \item How they are imported into networkx and became a tree
%     \item Explain how it is stored pickled 
%     \item Handling issues with recursion 
%     \item Issue with the naming of the defitions 
%     \item issue with where clause
% \end{itemize}

\subsubsection{Building definition graph}

The parsed dictionary from \cref{sub:s-expression parser implementation}
constructs the definition dependency graph using NetworkX, where keys become
nodes and dependency lists form edges. Nodes are added via
\texttt{add\_nodes\_from()} using dictionary keys, while edges are created
through \texttt{add\_edges\_from()} with \texttt{(definition, dependency)}
tuples. This creates directed edges from definitions to their dependencies. The
resulting graph is serialized using Python's Pickle library for storage and
reuse.

Definition names originally include module paths and identifiers from Agda's
internal representation. Before graph creation, these identifiers are removed
unless needed to resolve naming conflicts improving readability.

\subsubsection{Building module tree} \label{sub: Building Module Tree}

Agda has a built-in feature that creates a DOT file of the module dependency
graph of an Agda project. The file is imported into NetworkX, serialized and
stored for future use.

\subsection{Commands}

Most queries are the same between the definition graph and the module graph,
but the module graph is acyclic giving it different properties. These queries
can be explored in further detail in its repository \cite{agda_html}.


\subsubsection{Create Tree}

The create tree command will create the dependency graph for either definitions
or modules. It will perform the parsing and extraction automatically and save
the graph to the home directory or the path of option \texttt{-o}.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition create_tree "source/AllModulesIndex.lagda" -o=~/.agda_tree/def_tree.pickle
\end{lstlisting}
\end{minipage}

\subsubsection{Nodes}

The nodes query gets all the nodes in the graph, it returns a list with all the
definition names. For the \texttt{-c} option it will return the amount of nodes
in the graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition nodes
agda_tree definition nodes -c
\end{lstlisting}
\end{minipage}

\subsubsection{Find}

The find query gets all the names that match a regex pattern. There is a
\texttt{-name} option, if true then it will match the name of the definition
otherwise matches the whole name including its modules.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition find "\_\+\_"
agda_tree definition find "\_\+\_" -name
\end{lstlisting}
\end{minipage}

\subsubsection{Dependencies}

The dependencies query gets all dependencies (direct or indirect) of a
definition by traversing its child nodes in the directed graph.


\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition dependencies "InfinitePigeon.Addition.n-plus-zero-equals-n"
agda_tree definition dependencies -i "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Dependents}


The dependents query gets all dependents (direct or indirect) of a
definition by traversing its parent nodes in the directed graph.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition dependents "InfinitePigeon.Addition.n-plus-zero-equals-n"
agda_tree definition dependents -i "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Leafs}

The leafs query gets the definitions that have no dependencies, meaning they do
not have children.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition leafs
\end{lstlisting}
\end{minipage}

\subsubsection{Module Dependencies}

The module dependencies query gets the modules of the definitions from the
dependencies query. This query is exclusive to the definition graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition module_dependencies "InfinitePigeon.Addition.n-plus-zero-equals-n"
agda_tree definition module_dependencies -i "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Module Dependants}

The module dependents query gets the modules of the definitions from the
dependencies query. This query is exclusive to the definition graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition module_dependents -i "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Path To Leaf}

The path to leaf query finds the longest path from a definition to a leaf.
First all the simple paths are found, then they are measured for length and the
largest one is returned.

The definition dependency graph is cyclic while the module dependency graph is
acyclic, this causes a difference in performance.  The definition graph also
significantly large, so the amount of paths grows faster.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition path_to_leaf "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Roots}

The roots query gets the definitions that have no dependents, meaning they do
not have parents.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition roots
\end{lstlisting}
\end{minipage}

\subsubsection{Use Count}

The use count query gets the numbers of times a definition appear as a
dependency (directly or indirectly). This query either accepts a
\texttt{-top=n} option where it will return the top n most used modules or the
\texttt{-d=definition} option that finds how many times a specific definition
was used.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition uses -top=10
agda_tree definition uses -i -top=10
agda_tree definition uses -d "InfinitePigeon.Addition.n-plus-zero-equals-n"
agda_tree definition uses -d -i "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Module Path To Leaf}

The module path to leaf query gets the modules of the definitions from the path
to leaf query. This query is exclusive to the definition graph.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition module_path_to_leaf "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Type}

The type query gets the type of the definition. This data is collected during
the building of the definition graph. This query is exclusive to the definition
graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition type "InfinitePigeon.Addition.n-plus-zero-equals-n"
\end{lstlisting}
\end{minipage}

\subsubsection{Cycles}

The cycles query gets the simple cycles in the graph. Simple cycles are cycles
where nodes aren't repeated. This query is exclusive to the definition graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition cycles
\end{lstlisting}
\end{minipage}

\subsubsection{Save Tree}

The save tree query converts the graph into the DOT format. NetworkX allows for
this conversion using the pydot library. This query is exclusive to the
definition graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition save_tree "/tmp/definition.dot"
\end{lstlisting}
\end{minipage}

\subsubsection{Path Between}

The path between query finds the longest simple path between to definitions.
Simple paths are paths that do not repeat nodes. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree definition path_between "InfinitePigeon.Addition.n-plus-zero-equals-n" "MLTT.Natural-Numbers-Type.N"
\end{lstlisting}
\end{minipage}

\subsubsection{Level Sort}

The level sort query sorts the modules into levels based on how far they are
from a leaf module. This sorting is explained in \cref{sub:design level
strategy}. This query is exclusive to the module graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree module lvl_sort
\end{lstlisting}
\end{minipage}

\subsubsection{Topological Sort}

The topological sort query sorts the modules topologically. Topological sort
orders the modules into a list where a module only depends on previous modules
in the list. This query is exclusive to the module graph. 

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_tree module topo_sort
\end{lstlisting}
\end{minipage}

% \begin{itemize}
% \item Explain how each query is implemented 
% \item Explain what the english definition means for the graph 
% \item Explain what the technical challenges could be 
% \item Explain the algorithms that were used 
% \item Explain the properties of each graph and how that limits the queries 
% \item Explain the limitations of the algorithms used if any 
% \item Design on how the queries are executed using argparse
% \end{itemize}

\subsection{Command-Line Interface}\label{sub:Agda Tree CLI}

The CLI is implemented in Python, a widely used language that most users are
familiar with, for easier modification by the user. Python's
argparse library is used to handle user input, generate help messages, and
manage command parsing. The CLI includes a main parser with two subparsers: one
for definition queries and the other for module queries. Based on the user’s
input, the main parser delegates tasks to the appropriate subparser.

Query methods are stored in two files: \texttt{def\_cmds.py} (for definition
queries) and \texttt{mod\_cmds.py} (for module queries). Using Python’s inspect
library, the CLI automatically generates commands from these functions,
extracting their names, parameters, and documentation. Positional parameters
become required inputs, while optional parameters are specified with flags.
This approach ensures that adding or modifying queries only requires changes to
the respective function, with no need to manually update the CLI. Agda Tree's
definition and module help messages can be seen below in \cref{code:definition help}
and \cref{code:module help} respectively.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}[caption={Agda Tree Definition Help Message},label={code:definition help}]
usage: agda_tree definition [-h]
                            {create_tree,cycles,dependencies,
                            dependents, find,leafs,
                            module_dependencies,module_dependents,
                            module_path_to_leaf,nodes,path_between,
                            path_to_leaf, roots,save_tree,type,uses}
                            ...

positional arguments:
  {create_tree,cycles,dependencies,dependents,
  find,leafs,module_dependencies,module_dependents,
  module_path_to_leaf,nodes,path_between,path_to_leaf,
  roots,save_tree,type,uses}
    create_tree         Creates definition dependency tree from file, 
                        -output option to set the path 
                        to store the tree
    cycles              Cycles in graph
    dependencies        Definitions that definition d depends on,
                        -indirect will find the indirect dependencies
    dependents          Definitions that depend on definition d,
                        -indirect finds the indirect dependents
    find                Find definition through regex
    leafs               Definitions with no dependencies
    module_dependencies
                        Module dependencies of definition d, 
                        -indirect finds the indirect 
                        module dependencies
    module_dependents   Modules that depend on definition d, 
                        -indirect also gets the indirect 
                        module dependents
    module_path_to_leaf
                        Longest path from definition d to any leaf only
                        counting modules
    nodes               List of definitions, if -c flag is set returns 
                        the number of nodes
    path_between        Longest path between two definitions src 
                        and dst
    path_to_leaf        Longest path from defintion d to any leaf
    roots               Definitions that aren't used
    save_tree           Save definition graph as pydot
    type                Types of definition d
    uses                Counts amount of uses per definition, 
                        sorted in descending order, if -d is passed 
                        in a definitino it will return the uses 
                        of that definition

options:
  -h, --help            show this help message and exit
\end{lstlisting}
\end{minipage}

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}[caption={Agda Tree Module Help Message},label={code:module help}]
usage: agda_tree module [-h]
                        {complex_modules,create_tree,dependencies,
                        dependents,find,leafs,lvl_sort,nodes,
                        path_between,path_to_leaf,roots,topo_sort,
                        uses} ...

positional arguments:
  {complex_modules,create_tree,dependencies,
  dependents,find,leafs,lvl_sort,nodes,
  path_between,path_to_leaf,roots,topo_sort,
  uses}
    complex_modules     Get the top modules that have the most dependents
    create_tree         Creates modules dependency tree from file
    dependencies        Modules that module m imports
    dependents          Modules that import module m
    find                Find module through regex
    leafs               Modules with no imports
    lvl_sort            Level sort
    nodes               List of modules
    path_between        Longest path between two modules src and dst
    path_to_leaf        Longest path from module m to any leaf
    roots               Modules that aren't imported
    topo_sort           Topological sort
    uses                Counts how many times a module is imported, sorted
                        in descending order

options:
  -h, --help            show this help message and exit
\end{lstlisting}
\end{minipage}

Once user input is validated, the CLI loads the appropriate graph (definition
or module) and executes the query. Using the query name the respective function
is called. The query output is printed to the console, enabling integration
with other terminal commands via piping.

% \begin{itemize}
% \item Explain why using python
% \item Explain what argparse is 
% \item Explain how the functions are stored in a file and the methods are read into for extensibility, one responsibility principle and open close principle.
% \item How the function parameters are added to the cli 
% \item Explain why it is good to be a cli tool, as it can be piped and used like any other command (wz, fzf, cp) 
% \item How clojure failed 
% \item How cycles are difficult andc ant find distance to leafe 
% \end{itemize}

\subsection{Installation} \label{sub:Agda Tree Installation}

To distribute and install the tool, it is packaged using a \texttt{pyproject.toml} file,
which defines the project’s metadata, dependencies, and supported Python
version. The Hatchling backend is used to build the distribution, enabling
installation on other systems. 

For installation, Python's package manager, PIP, can be used to install the
tool locally. Simply run \texttt{pip install .} in the project directory.
However, it is recommended to use PIPX. PIPX isolates the tool’s environment
from the rest of the system, preventing dependency conflicts. Users can install
PIPX through their respective package managers.

\subsection{Installing Agda S-Expression Extractor}


The Agda S-expression extractor, an extension of the Agda backend developed by
Andrej Bauer \cite{andrej}, is not pre-built for download and must be manually
built. Agda Tree includes a script that automates this installation.

The script clones the repository into a temporary directory, checks out the
branch compatible with the latest Agda version (2.7.0.1), and uses Stack to
build the extractor. Stack, a Haskell build tool and dependency manager, is
commonly used by Agda developers and can be installed via most package
managers. The repository includes a YAML configuration file with instructions
for building the binaries. Once built, the binary is copied to the
\texttt{~/.local/bin/} directory, which is typically included in the user's
path.

After installation, the extractor can be accessed using the agdasexp command.
The Agda Tree tool automatically detects this command and uses it to generate
definition dependency graphs.

% \begin{itemize}
% \item Explain how dependencies are handle 
% \item Explain how this can be installed as a project using pip 
% \item The tool automatically isntalls agdasexp 
% \end{itemize}

\section{Agda Comp}

Agda Comp\cite{agda_html} automatically creates the module dependency graph as described in
\cref{sub: Building Module Tree}, using Agda's built-in command. The graph is
passed into a strategy, that will return the order in which to compile
the modules. Given this order, a 'make generator' sub-system creates the index
files and the make file which compile the modules in parallel following the
order.

\subsection{Strategies}

Each strategy processes the module dependency graph, represented as a directed
graph using NetworkX. In this graph, nodes are modules, and edges points to
its dependencies. To compile a module, all its dependencies must be compiled
first. Additionally, two modules cannot be compiled simultaneously if they
share dependencies, as this could lead to conflicts. A valid strategy compiles
all modules safely.

The strategies produce a 3D array that defines the order of compilation and
identifies which modules can be compiled in parallel. An index file groups
modules that are compiled together. If two indices have disjoint
dependencies, they can be compiled in parallel. The array specifies the
compilation order by grouping indices into sequential phases. For example:

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
[
  [[module1, module2], [module3, module4]],  # Phase 0
  [[module5]],                               # Phase 1
  [[module6, module7]]                       # Phase 2
]
\end{lstlisting}
\end{minipage}

In this example, \texttt{module1} and \texttt{module2} are compiled together in one index file,
while \texttt{module3} and \texttt{module4} are grouped into another index file. Both index files
are compiled in parallel during Phase 0. In Phase 1, \texttt{module5} is compiled on its
own, followed by \texttt{module6} and \texttt{module7} in Phase 2.

When Agda compiles a module, it loads the interface files of its dependencies.
By grouping multiple modules into a single index file, shared interface files
are loaded once for the entire group rather than repeatedly for each module.

Finally, the make generator subsystem uses this array to create both index
files and a Makefile. The Makefile ensures that indices are compiled in the
correct order while taking advantage of parallelism wherever possible.

\subsubsection{Level Strategy} \label{sub:imp lvl strategy}

The level strategy, as explained in \cref{sub:design level strategy}, orders
modules into levels based on their maximum distance from a leaf node.
Dependencies in previous the levels are compiled before modules in the next
levels. This guarantees safe parallel compilation within each level. The
algorithm works recursively as shown below in \cref{code:lvl sort}. Once sorted,
modules at the same level are grouped into index files, where each index file
can be compiled concurrently. This array is then used to generate a Makefile
that runs the compilation sequence, as explained in
\cref{sub:build_make_index}.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}[caption={Level Sort Algorithm},label={code:lvl sort}]
def depth(g, node, mem):
    if node in mem:
        return mem

    children = list(g.successors(node))
    if len(children) == 0:
        mem[node] = 0
        return mem

    for c in children:
        m = depth(g, c, mem)
        mem |= m
        mem[node] = max(mem.get(node, 0), mem[c])
    mem[node] += 1

    return mem

def depths(g):
    m = {}
    for n in g.nodes:
        m |= depth(g, n, m)
    return m
\end{lstlisting}
\end{minipage}

When Agda type-checks a module, it reloads the dependency's interface files
which could be large. To avoid reloading these files, the strategy groups
modules within the same level into index files. Then interface files will load
once per index rather than per module, reducing overhead. Two methods are
employed to split modules into index files:

Method A: modules are split evenly across index files, where the split is
guided by the available CPU cores. Creating more index files  that cores could
cause two compilations to share a core, reducing effectiveness.

Method B: caps the number of modules per index file, creating more files when
the threshold is exceeded. While this may produce more index files than cores,
it could mean that while one compilation is waiting for their interface files
another is running their compilation. 

These approaches (labelled Level A and Level B in \cref{sub:eval comp strat})
were tested to evaluate their impact on compilation time across multiple
projects and computers.

\subsubsection{Level Disjoint Strategy} \label{sub:imp disj strategy}

The level disjoint strategy, as described in \cref{sub:design disjoint strategy}, addresses the limitations of the level sort strategy by focusing on
large modules with many distinct dependencies. These modules, referred to as
disjoint modules, are compiled first. If no disjoint modules are found, the
strategy compiles leaf nodes, eliminating shared dependencies. This iterative
approach means that the algorithm terminates when all modules have been
compiled.


Identifying disjoint modules is challenging, especially for large projects with
hundreds of modules. A brute-force approach is computationally not possible. So
a greedy approach is used to approximate these modules. The algorithm sorts
modules: first by the number leaf nodes they depend on (in ascending order),
and then by the total number of dependencies (in descending order to break
ties). This sorting prioritizes modules with few leafs and  many dependencies.

After sorting, the algorithm groups modules into buckets based on their leafs.
A new bucket is created for the first module in the sorted list, and subsequent
modules are either added to existing buckets or ignored based on how their
leafs overlap. Modules that share all leaf dependencies with a bucket are added
to that bucket, while those sharing only some dependencies are ignored. Buckets
represent groups of modules that can be compiled in parallel safely.

The compilation order array generated by this strategy begins with a step for
compiling the leaf nodes sequentially. The buckets are then added as parallel
compilation step. If only one bucket is found it is combined with leaf nodes
into a single compilation step to avoid overhead. This ensures that all
modules are eventually included in either a leaf step or a bucket step.

% \begin{itemize}
% \item mention combining linear steps into one big step
% \item Explain each strategy 
% \item How it works 
% \item Explain how you find modified files
% \item What the motivation for it is 
% \item Implication on parallelization 
% \item How it was tested for safety and correctness 
% \item Why using index files, to gropu these modules 
% \item How the algorithm is safe and correct 
% \item How make files work 
% \item Why use make files over other options 
% \item What the output of the algorithms is 
% \item Difficulty with diferenct directory names and index flags
% \item The limitations of each algorithm, pros and cons 
% \item How idsjoint is np-hard, greedy algorithm to find it 
% \item There is no good way to find disjoint modules 
% \item level sort compiles onde modules at a time, meaning .agdai files are constantly loaded.
% \end{itemize}

\subsection{Building The Make File And Indices} \label{sub:build_make_index}

An index file is a module that imports other modules but contains no
definitions. Its purpose is to allow the type-checking of multiple modules as a
group. Each index file starts with flags that modify the behaviour of the type
checker. These flags vary between projects and are extracted from an index file
provided by the user. Below is an example of an index file from the
TypeTopology project:

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
    
Generated Index file

\begin{code}
    {-# OPTIONS --without-K --type-in-type --no-level-universe --no-termination-check --guardedness #-}
    import MLTT.Universes
    import MLTT.Natural-Numbers-Type
    import InfinitePigeon.Logic
    import Various.UnivalenceFromScratch
\end{code}
\end{lstlisting}
\end{minipage}

Index files are named according to their compilation order. For instance,
\texttt{index-0-0} and \texttt{index-0-1} represent files compiled first in parallel, followed by
\texttt{index-1-x} files compiled after. 

The Makefile defines the list of commands required to compile a project. It
consists of "targets," which specify what to build, how to build it, and their
prerequisites. For example, to compile \texttt{index-1-2.lagda}, its
prerequisites (\texttt{index-1-0.lagda} and \texttt{index-1-1.lagda)} must be
compiled first. The \texttt{all:} target compiles the entire project starting
from the highest-level index file (\texttt{index-2-0.lagda}). Agda compiles
modules into interface files with the \texttt{.agdai} extension. If an
interface file does not exist, it triggers its compilation
before dependent targets.

Example:

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
all: _build/2.7.0.1/agda/source/index-1-2.agdai 

_build/2.7.0.1/agda/source/index-0-0.agdai: 
	agda ./source/index-0-0.lagda

_build/2.7.0.1/agda/source/index-1-0.agdai: _build/2.7.0.1/agda/source/index-0-0.agdai 
	agda ./source/index-1-0.lagda

_build/2.7.0.1/agda/source/index-1-1.agdai: _build/2.7.0.1/agda/source/index-0-0.agdai 
	agda ./source/index-1-1.lagda

_build/2.7.0.1/agda/source/index-2-0.agdai: _build/2.7.0.1/agda/source/index-1-0.agdai _build/2.7.0.1/agda/source/index-1-1.agdai _build/2.7.0.1/agda/source/index-1-2.agdai _build/2.7.0.1/agda/source/index-1-3.agdai 
	agda ./source/index-2-0.lagda
\end{lstlisting}
\end{minipage}

If two targets do not share dependencies, they are compiled in parallel
automatically by the Makefile. For instance, \texttt{index-1-0.lagda}
and \\\texttt{index-1-1.lagda} can be compiled together.

The Makefile is generated based on the output of the chosen compilation
strategy. Each index file corresponds to a target named after its position in
the compilation order array, with prerequisites being the previous index
files in the array. The final target includes all previous indices and is added
to the \texttt{all:} target for complete project compilation. Initial index files
without dependencies have no prerequisites.

\subsection{Command-Line Interface}

The Command-Line Interface (CLI) is implemented in Python, as most users are
likely to have it installed and may already be familiar with it. Similar to the
Agda Tree CLI (\cref{sub:Agda Tree CLI}), the argparse library is used to parse
user input, validate commands, and generate usage and help messages. The parser
accepts the path to the module file to compile as a positional parameter while
allowing additional options to customize the compilation process, such as
selecting a strategy. The help message detailing these options is displayed in
\cref{code:agda comp help} below.

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}[caption={Agda Comp Help Message},label={code:agda comp help}]
usage: agda_comp [-h] [-c] [-j JOBS] [-s {level,levelb,normal,unsafe,disjoint}] module

Fast Agda type checker

positional arguments:
  module                Path to module to compile

options:
  -h, --help            show this help message and exit
  -c, --clean           Create dot file even if it already exists
  -j, --jobs JOBS       Cores that can be used
  -s, --strategy {level,levelb,normal,unsafe,disjoint}
			The strategy that will determine the compilation order,
			the choices are: level: Sorts modules into levels, each
			level increses the length to a leaf, lvl 5 are the
			modules that 5 modules away from a leaf. Each level is
			then split into 4 files or the value given by --jobs
			levelb: Sorts modules by levels like in 'level' but
			instead each level is separated into n files with
			--jobs modules each normal: Normal compilation unsafe:
			Tries to compile all the modules with 4 concurrent
			index files or --jobs files disjoint: Finds the biggest
			modules that are disjoint, if none are found the leaves
			are removed then repeats
\end{lstlisting}
\end{minipage}



The CLI provides three main options: \texttt{clean,} \texttt{jobs,} and
\texttt{strategy.} By default, the tool reuses the existing module dependency
graph and excludes already compiled modules from further compilation. The clean
option forces regeneration of the module dependency graph and deletes the
\texttt{\_build} directory containing compiled modules. Agda Comp determines
whether a module is already compiled by checking if its corresponding interface
file exists and whether it has been modified since its creation. If a module
has been altered, it is recompiled. The jobs option specifies how many CPU
cores should be used during compilation. Finally, the strategy option allows
users to choose which compilation strategy to apply.


When the user provides the index file path and options, the tool
generates index files and a Makefile. These files are then moved to their
respective directories: index files to the project source directory and
Makefiles to the project root directory. The command \texttt{mk compilation.mk} is
executed, where \texttt{compilation.mk} is the generated Makefile. This command
compiles the project using the specified number of cores. Upon completion, both
index files and Makefiles are deleted to maintain a clean project directory. If
the user cancels compilation midway, a listener will remove the temporary
files, preventing clutter in the project.


For example, to compile TypeTopology using two cores, deleting previously
compiled modules, regenerating the module dependency graph, and applying the
Level B strategy, the following command can be used:

\noindent
\begin{minipage}{\textwidth}
\begin{lstlisting}
agda_comp -j=2 -c  --strategy=levelb "/tmp/TypeTopology/source/AllModulesIndex.lagda"
\end{lstlisting}
\end{minipage}

\subsection{Installation}

The installation process for this tool is the same as for Agda Tree in 
\cref{sub:Agda Tree Installation}. A pyproject.toml file that describes
the dependencies, backend and python version of the project along with
other metadata. This packages the project such that it can be installed through
PIP, although PIPX is recommended to install end-user applications as PIPX will
isolate the dependencies of Agda Comp from the packages of the user.

% \begin{itemize}
% \item Explain why using python
% \item Explain what argparse is 
% \item Explain how the functions are stored in a file and the methods are read into for extensibility, one responsibility principle and open close principle.
% \item How the function parameters are added to the cli 
% \item Explain how dependencies are handle 
% \item Explain how this can be installed as a project using pip 
% \item Explain why it is good to be a cli tool, as it can be piped and used like any other command (wz, fzf, cp) 
% \item How it is installed 
% \item How the user can use it
% \item How it creates the module dependency graph
% \item How it uses the strategies
% \item how it uses hte make and index files
% \item How the modification timestamp is checked to avoid recompiling files.
% \end{itemize}

\section{Conclusion}

Agda Tree uses Andrej Bauer's s-expression extractor to create the s-expression
files, which are then imported as lists into python using the sexpdata library.
These lists are explored to find all the definitions and their relationships
which are then converted into a graph in NetworkX.  Then the CLI exposes
queries that can be made to the dependency graph for the user to learn more
about the relationship of these definitions. The tools are packaged to be easy
to install and the building of the s-expression extractor is handled.

Agda Comp uses different strategies to analyse Agda's module dependency graph
to improve compilation time. The strategies read the dependency graph and
return a list that shows the order in which to compile the modules. With this
order, index files and a make file is generated that will compile the modules
in the correct order. The make file compiles the project, then deletes itself
along with the index file to leave the user with a clean project. Agda Comp can
use different strategies and change the amount of cores used. The tool is easy
to install with PIPX and doesn't require any external dependencies that can't
be installed through PIP.


% \begin{itemize}
% \item Unit testing and integration testing 
% \item Documentation and version control strategies
% \end{itemize}

% \begin{itemize}
% \item Explain the s-expressions extractor
% \item How they are loaded into python 
% \item How they are stored for future use 
% \item How the compilation uses graph dot
% \end{itemize}

